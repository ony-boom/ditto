// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package database

import (
	"context"
	"database/sql"
)

const createPackage = `-- name: CreatePackage :one
INSERT INTO
    packages (name, host)
VALUES
    (?, ?)
RETURNING
    id,
    name,
    host
`

type CreatePackageParams struct {
	Name string
	Host sql.NullString
}

type CreatePackageRow struct {
	ID   int64
	Name string
	Host sql.NullString
}

func (q *Queries) CreatePackage(ctx context.Context, arg CreatePackageParams) (CreatePackageRow, error) {
	row := q.db.QueryRowContext(ctx, createPackage, arg.Name, arg.Host)
	var i CreatePackageRow
	err := row.Scan(&i.ID, &i.Name, &i.Host)
	return i, err
}

const createPackageWithoutHost = `-- name: CreatePackageWithoutHost :one
INSERT INTO
    packages (name)
VALUES
    (?)
RETURNING
    id,
    name,
    host
`

type CreatePackageWithoutHostRow struct {
	ID   int64
	Name string
	Host sql.NullString
}

func (q *Queries) CreatePackageWithoutHost(ctx context.Context, name string) (CreatePackageWithoutHostRow, error) {
	row := q.db.QueryRowContext(ctx, createPackageWithoutHost, name)
	var i CreatePackageWithoutHostRow
	err := row.Scan(&i.ID, &i.Name, &i.Host)
	return i, err
}

const deletePackage = `-- name: DeletePackage :exec
DELETE FROM
    packages
WHERE
    name = ?
`

func (q *Queries) DeletePackage(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, deletePackage, name)
	return err
}

const deletePackageByNameAndHost = `-- name: DeletePackageByNameAndHost :exec
DELETE FROM
    packages
WHERE
    name = ?
    AND (
        host = ?
        OR (
            host IS NULL
            AND ? IS NULL
        )
    )
`

type DeletePackageByNameAndHostParams struct {
	Name    string
	Host    sql.NullString
	Column3 interface{}
}

func (q *Queries) DeletePackageByNameAndHost(ctx context.Context, arg DeletePackageByNameAndHostParams) error {
	_, err := q.db.ExecContext(ctx, deletePackageByNameAndHost, arg.Name, arg.Host, arg.Column3)
	return err
}

const deletePackagesByHost = `-- name: DeletePackagesByHost :exec
DELETE FROM
    packages
WHERE
    (
        host = ?
        OR (
            host IS NULL
            AND ? IS NULL
        )
    )
`

type DeletePackagesByHostParams struct {
	Host    sql.NullString
	Column2 interface{}
}

func (q *Queries) DeletePackagesByHost(ctx context.Context, arg DeletePackagesByHostParams) error {
	_, err := q.db.ExecContext(ctx, deletePackagesByHost, arg.Host, arg.Column2)
	return err
}

const getPackageByName = `-- name: GetPackageByName :one
SELECT
    id,
    name,
    host
FROM
    packages
WHERE
    name = ?
`

type GetPackageByNameRow struct {
	ID   int64
	Name string
	Host sql.NullString
}

func (q *Queries) GetPackageByName(ctx context.Context, name string) (GetPackageByNameRow, error) {
	row := q.db.QueryRowContext(ctx, getPackageByName, name)
	var i GetPackageByNameRow
	err := row.Scan(&i.ID, &i.Name, &i.Host)
	return i, err
}

const getPackageByNameAndHost = `-- name: GetPackageByNameAndHost :one
SELECT
    id,
    name,
    host
FROM
    packages
WHERE
    name = ?
    AND (
        host = ?
        OR (
            host IS NULL
            AND ? IS NULL
        )
    )
`

type GetPackageByNameAndHostParams struct {
	Name    string
	Host    sql.NullString
	Column3 interface{}
}

type GetPackageByNameAndHostRow struct {
	ID   int64
	Name string
	Host sql.NullString
}

func (q *Queries) GetPackageByNameAndHost(ctx context.Context, arg GetPackageByNameAndHostParams) (GetPackageByNameAndHostRow, error) {
	row := q.db.QueryRowContext(ctx, getPackageByNameAndHost, arg.Name, arg.Host, arg.Column3)
	var i GetPackageByNameAndHostRow
	err := row.Scan(&i.ID, &i.Name, &i.Host)
	return i, err
}

const getPackages = `-- name: GetPackages :many
SELECT
    id,
    name,
    host
FROM
    packages
ORDER BY
    name
`

type GetPackagesRow struct {
	ID   int64
	Name string
	Host sql.NullString
}

func (q *Queries) GetPackages(ctx context.Context) ([]GetPackagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPackages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPackagesRow
	for rows.Next() {
		var i GetPackagesRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Host); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPackagesByHost = `-- name: GetPackagesByHost :many
SELECT
    id,
    name,
    host
FROM
    packages
WHERE
    (
        host = ?
        OR (
            host IS NULL
            AND ? IS NULL
        )
    )
`

type GetPackagesByHostParams struct {
	Host    sql.NullString
	Column2 interface{}
}

type GetPackagesByHostRow struct {
	ID   int64
	Name string
	Host sql.NullString
}

func (q *Queries) GetPackagesByHost(ctx context.Context, arg GetPackagesByHostParams) ([]GetPackagesByHostRow, error) {
	rows, err := q.db.QueryContext(ctx, getPackagesByHost, arg.Host, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPackagesByHostRow
	for rows.Next() {
		var i GetPackagesByHostRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Host); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertPackage = `-- name: UpsertPackage :one
INSERT INTO
    packages (name, host)
VALUES
    (?, ?) ON CONFLICT (name, host) DO
UPDATE
SET
    name = EXCLUDED.name,
    host = EXCLUDED.host
RETURNING
    id,
    name,
    host
`

type UpsertPackageParams struct {
	Name string
	Host sql.NullString
}

type UpsertPackageRow struct {
	ID   int64
	Name string
	Host sql.NullString
}

func (q *Queries) UpsertPackage(ctx context.Context, arg UpsertPackageParams) (UpsertPackageRow, error) {
	row := q.db.QueryRowContext(ctx, upsertPackage, arg.Name, arg.Host)
	var i UpsertPackageRow
	err := row.Scan(&i.ID, &i.Name, &i.Host)
	return i, err
}

const upsertPackageWithoutHost = `-- name: UpsertPackageWithoutHost :one
INSERT INTO
    packages (name)
VALUES
    (?) ON CONFLICT (name) DO
UPDATE
SET
    name = EXCLUDED.name
RETURNING
    id,
    name,
    host
`

type UpsertPackageWithoutHostRow struct {
	ID   int64
	Name string
	Host sql.NullString
}

func (q *Queries) UpsertPackageWithoutHost(ctx context.Context, name string) (UpsertPackageWithoutHostRow, error) {
	row := q.db.QueryRowContext(ctx, upsertPackageWithoutHost, name)
	var i UpsertPackageWithoutHostRow
	err := row.Scan(&i.ID, &i.Name, &i.Host)
	return i, err
}
